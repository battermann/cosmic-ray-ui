-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module ReadModel.InputObject exposing (Challenges_bool_exp(..), Challenges_bool_expOptionalFields, Challenges_bool_expRaw, Challenges_order_by, Challenges_order_byOptionalFields, Color_bool_exp(..), Color_bool_expOptionalFields, Color_bool_expRaw, Color_enum_comparison_exp, Color_enum_comparison_expOptionalFields, Color_order_by, Color_order_byOptionalFields, Game_args, Game_argsOptionalFields, Game_state_bool_exp(..), Game_state_bool_expOptionalFields, Game_state_bool_expRaw, Game_state_enum_comparison_exp, Game_state_enum_comparison_expOptionalFields, Game_state_order_by, Game_state_order_byOptionalFields, Games_bool_exp(..), Games_bool_expOptionalFields, Games_bool_expRaw, Games_order_by, Games_order_byOptionalFields, Int4_comparison_exp_, Int4_comparison_exp_OptionalFields, Int_comparison_exp, Int_comparison_expOptionalFields, Live_games_args, Live_games_argsOptionalFields, My_challenges_args, My_challenges_argsOptionalFields, My_games_args, My_games_argsOptionalFields, Player_bool_exp(..), Player_bool_expOptionalFields, Player_bool_expRaw, Player_enum_comparison_exp, Player_enum_comparison_expOptionalFields, Player_order_by, Player_order_byOptionalFields, String_comparison_exp, String_comparison_expOptionalFields, Uuid_comparison_exp, Uuid_comparison_expOptionalFields, Villain_challenges_args, Villain_challenges_argsOptionalFields, buildChallenges_bool_exp, buildChallenges_order_by, buildColor_bool_exp, buildColor_enum_comparison_exp, buildColor_order_by, buildGame_args, buildGame_state_bool_exp, buildGame_state_enum_comparison_exp, buildGame_state_order_by, buildGames_bool_exp, buildGames_order_by, buildInt4_comparison_exp_, buildInt_comparison_exp, buildLive_games_args, buildMy_challenges_args, buildMy_games_args, buildPlayer_bool_exp, buildPlayer_enum_comparison_exp, buildPlayer_order_by, buildString_comparison_exp, buildUuid_comparison_exp, buildVillain_challenges_args, encodeChallenges_bool_exp, encodeChallenges_order_by, encodeColor_bool_exp, encodeColor_enum_comparison_exp, encodeColor_order_by, encodeGame_args, encodeGame_state_bool_exp, encodeGame_state_enum_comparison_exp, encodeGame_state_order_by, encodeGames_bool_exp, encodeGames_order_by, encodeInt4_comparison_exp_, encodeInt_comparison_exp, encodeLive_games_args, encodeMy_challenges_args, encodeMy_games_args, encodePlayer_bool_exp, encodePlayer_enum_comparison_exp, encodePlayer_order_by, encodeString_comparison_exp, encodeUuid_comparison_exp, encodeVillain_challenges_args)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode
import ReadModel.Enum.Color_enum
import ReadModel.Enum.Game_state_enum
import ReadModel.Enum.Order_by
import ReadModel.Enum.Player_enum
import ReadModel.Interface
import ReadModel.Object
import ReadModel.Scalar
import ReadModel.Union
import ScalarCodecs


buildChallenges_bool_exp : (Challenges_bool_expOptionalFields -> Challenges_bool_expOptionalFields) -> Challenges_bool_exp
buildChallenges_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, color = Absent, colorByColor = Absent, id = Absent, serial_id = Absent }
    in
    Challenges_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, color = optionals.color, colorByColor = optionals.colorByColor, id = optionals.id, serial_id = optionals.serial_id }


type alias Challenges_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Challenges_bool_exp))
    , not_ : OptionalArgument Challenges_bool_exp
    , or_ : OptionalArgument (List (Maybe Challenges_bool_exp))
    , color : OptionalArgument Color_enum_comparison_exp
    , colorByColor : OptionalArgument Color_bool_exp
    , id : OptionalArgument Uuid_comparison_exp
    , serial_id : OptionalArgument Int_comparison_exp
    }


{-| Type alias for the `Challenges_bool_exp` attributes. Note that this type
needs to use the `Challenges_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Challenges_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Challenges_bool_exp))
    , not_ : OptionalArgument Challenges_bool_exp
    , or_ : OptionalArgument (List (Maybe Challenges_bool_exp))
    , color : OptionalArgument Color_enum_comparison_exp
    , colorByColor : OptionalArgument Color_bool_exp
    , id : OptionalArgument Uuid_comparison_exp
    , serial_id : OptionalArgument Int_comparison_exp
    }


{-| Type for the Challenges\_bool\_exp input object.
-}
type Challenges_bool_exp
    = Challenges_bool_exp Challenges_bool_expRaw


{-| Encode a Challenges\_bool\_exp into a value that can be used as an argument.
-}
encodeChallenges_bool_exp : Challenges_bool_exp -> Value
encodeChallenges_bool_exp (Challenges_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeChallenges_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeChallenges_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeChallenges_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "color", encodeColor_enum_comparison_exp |> Encode.optional input.color ), ( "colorByColor", encodeColor_bool_exp |> Encode.optional input.colorByColor ), ( "id", encodeUuid_comparison_exp |> Encode.optional input.id ), ( "serial_id", encodeInt_comparison_exp |> Encode.optional input.serial_id ) ]


buildChallenges_order_by : (Challenges_order_byOptionalFields -> Challenges_order_byOptionalFields) -> Challenges_order_by
buildChallenges_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { color = Absent, colorByColor = Absent, id = Absent, serial_id = Absent }
    in
    { color = optionals.color, colorByColor = optionals.colorByColor, id = optionals.id, serial_id = optionals.serial_id }


type alias Challenges_order_byOptionalFields =
    { color : OptionalArgument ReadModel.Enum.Order_by.Order_by
    , colorByColor : OptionalArgument Color_order_by
    , id : OptionalArgument ReadModel.Enum.Order_by.Order_by
    , serial_id : OptionalArgument ReadModel.Enum.Order_by.Order_by
    }


{-| Type for the Challenges\_order\_by input object.
-}
type alias Challenges_order_by =
    { color : OptionalArgument ReadModel.Enum.Order_by.Order_by
    , colorByColor : OptionalArgument Color_order_by
    , id : OptionalArgument ReadModel.Enum.Order_by.Order_by
    , serial_id : OptionalArgument ReadModel.Enum.Order_by.Order_by
    }


{-| Encode a Challenges\_order\_by into a value that can be used as an argument.
-}
encodeChallenges_order_by : Challenges_order_by -> Value
encodeChallenges_order_by input =
    Encode.maybeObject
        [ ( "color", Encode.enum ReadModel.Enum.Order_by.toString |> Encode.optional input.color ), ( "colorByColor", encodeColor_order_by |> Encode.optional input.colorByColor ), ( "id", Encode.enum ReadModel.Enum.Order_by.toString |> Encode.optional input.id ), ( "serial_id", Encode.enum ReadModel.Enum.Order_by.toString |> Encode.optional input.serial_id ) ]


buildColor_bool_exp : (Color_bool_expOptionalFields -> Color_bool_expOptionalFields) -> Color_bool_exp
buildColor_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, challenges = Absent, value = Absent }
    in
    Color_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, challenges = optionals.challenges, value = optionals.value }


type alias Color_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Color_bool_exp))
    , not_ : OptionalArgument Color_bool_exp
    , or_ : OptionalArgument (List (Maybe Color_bool_exp))
    , challenges : OptionalArgument Challenges_bool_exp
    , value : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Color_bool_exp` attributes. Note that this type
needs to use the `Color_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Color_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Color_bool_exp))
    , not_ : OptionalArgument Color_bool_exp
    , or_ : OptionalArgument (List (Maybe Color_bool_exp))
    , challenges : OptionalArgument Challenges_bool_exp
    , value : OptionalArgument String_comparison_exp
    }


{-| Type for the Color\_bool\_exp input object.
-}
type Color_bool_exp
    = Color_bool_exp Color_bool_expRaw


{-| Encode a Color\_bool\_exp into a value that can be used as an argument.
-}
encodeColor_bool_exp : Color_bool_exp -> Value
encodeColor_bool_exp (Color_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeColor_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeColor_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeColor_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "challenges", encodeChallenges_bool_exp |> Encode.optional input.challenges ), ( "value", encodeString_comparison_exp |> Encode.optional input.value ) ]


buildColor_enum_comparison_exp : (Color_enum_comparison_expOptionalFields -> Color_enum_comparison_expOptionalFields) -> Color_enum_comparison_exp
buildColor_enum_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, in_ = Absent, is_null_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, in_ = optionals.in_, is_null_ = optionals.is_null_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Color_enum_comparison_expOptionalFields =
    { eq_ : OptionalArgument ReadModel.Enum.Color_enum.Color_enum
    , in_ : OptionalArgument (List ReadModel.Enum.Color_enum.Color_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument ReadModel.Enum.Color_enum.Color_enum
    , nin_ : OptionalArgument (List ReadModel.Enum.Color_enum.Color_enum)
    }


{-| Type for the Color\_enum\_comparison\_exp input object.
-}
type alias Color_enum_comparison_exp =
    { eq_ : OptionalArgument ReadModel.Enum.Color_enum.Color_enum
    , in_ : OptionalArgument (List ReadModel.Enum.Color_enum.Color_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument ReadModel.Enum.Color_enum.Color_enum
    , nin_ : OptionalArgument (List ReadModel.Enum.Color_enum.Color_enum)
    }


{-| Encode a Color\_enum\_comparison\_exp into a value that can be used as an argument.
-}
encodeColor_enum_comparison_exp : Color_enum_comparison_exp -> Value
encodeColor_enum_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.enum ReadModel.Enum.Color_enum.toString |> Encode.optional input.eq_ ), ( "_in", (Encode.enum ReadModel.Enum.Color_enum.toString |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_neq", Encode.enum ReadModel.Enum.Color_enum.toString |> Encode.optional input.neq_ ), ( "_nin", (Encode.enum ReadModel.Enum.Color_enum.toString |> Encode.list) |> Encode.optional input.nin_ ) ]


buildColor_order_by : (Color_order_byOptionalFields -> Color_order_byOptionalFields) -> Color_order_by
buildColor_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { value = Absent }
    in
    { value = optionals.value }


type alias Color_order_byOptionalFields =
    { value : OptionalArgument ReadModel.Enum.Order_by.Order_by }


{-| Type for the Color\_order\_by input object.
-}
type alias Color_order_by =
    { value : OptionalArgument ReadModel.Enum.Order_by.Order_by }


{-| Encode a Color\_order\_by into a value that can be used as an argument.
-}
encodeColor_order_by : Color_order_by -> Value
encodeColor_order_by input =
    Encode.maybeObject
        [ ( "value", Encode.enum ReadModel.Enum.Order_by.toString |> Encode.optional input.value ) ]


buildGame_args : (Game_argsOptionalFields -> Game_argsOptionalFields) -> Game_args
buildGame_args fillOptionals =
    let
        optionals =
            fillOptionals
                { game_id = Absent, my_id = Absent }
    in
    { game_id = optionals.game_id, my_id = optionals.my_id }


type alias Game_argsOptionalFields =
    { game_id : OptionalArgument ScalarCodecs.Uuid
    , my_id : OptionalArgument ScalarCodecs.Uuid
    }


{-| Type for the Game\_args input object.
-}
type alias Game_args =
    { game_id : OptionalArgument ScalarCodecs.Uuid
    , my_id : OptionalArgument ScalarCodecs.Uuid
    }


{-| Encode a Game\_args into a value that can be used as an argument.
-}
encodeGame_args : Game_args -> Value
encodeGame_args input =
    Encode.maybeObject
        [ ( "game_id", (ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.game_id ), ( "my_id", (ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.my_id ) ]


buildGame_state_bool_exp : (Game_state_bool_expOptionalFields -> Game_state_bool_expOptionalFields) -> Game_state_bool_exp
buildGame_state_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, games = Absent, value = Absent }
    in
    Game_state_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, games = optionals.games, value = optionals.value }


type alias Game_state_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Game_state_bool_exp))
    , not_ : OptionalArgument Game_state_bool_exp
    , or_ : OptionalArgument (List (Maybe Game_state_bool_exp))
    , games : OptionalArgument Games_bool_exp
    , value : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Game_state_bool_exp` attributes. Note that this type
needs to use the `Game_state_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Game_state_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Game_state_bool_exp))
    , not_ : OptionalArgument Game_state_bool_exp
    , or_ : OptionalArgument (List (Maybe Game_state_bool_exp))
    , games : OptionalArgument Games_bool_exp
    , value : OptionalArgument String_comparison_exp
    }


{-| Type for the Game\_state\_bool\_exp input object.
-}
type Game_state_bool_exp
    = Game_state_bool_exp Game_state_bool_expRaw


{-| Encode a Game\_state\_bool\_exp into a value that can be used as an argument.
-}
encodeGame_state_bool_exp : Game_state_bool_exp -> Value
encodeGame_state_bool_exp (Game_state_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeGame_state_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeGame_state_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeGame_state_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "games", encodeGames_bool_exp |> Encode.optional input.games ), ( "value", encodeString_comparison_exp |> Encode.optional input.value ) ]


buildGame_state_enum_comparison_exp : (Game_state_enum_comparison_expOptionalFields -> Game_state_enum_comparison_expOptionalFields) -> Game_state_enum_comparison_exp
buildGame_state_enum_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, in_ = Absent, is_null_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, in_ = optionals.in_, is_null_ = optionals.is_null_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Game_state_enum_comparison_expOptionalFields =
    { eq_ : OptionalArgument ReadModel.Enum.Game_state_enum.Game_state_enum
    , in_ : OptionalArgument (List ReadModel.Enum.Game_state_enum.Game_state_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument ReadModel.Enum.Game_state_enum.Game_state_enum
    , nin_ : OptionalArgument (List ReadModel.Enum.Game_state_enum.Game_state_enum)
    }


{-| Type for the Game\_state\_enum\_comparison\_exp input object.
-}
type alias Game_state_enum_comparison_exp =
    { eq_ : OptionalArgument ReadModel.Enum.Game_state_enum.Game_state_enum
    , in_ : OptionalArgument (List ReadModel.Enum.Game_state_enum.Game_state_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument ReadModel.Enum.Game_state_enum.Game_state_enum
    , nin_ : OptionalArgument (List ReadModel.Enum.Game_state_enum.Game_state_enum)
    }


{-| Encode a Game\_state\_enum\_comparison\_exp into a value that can be used as an argument.
-}
encodeGame_state_enum_comparison_exp : Game_state_enum_comparison_exp -> Value
encodeGame_state_enum_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.enum ReadModel.Enum.Game_state_enum.toString |> Encode.optional input.eq_ ), ( "_in", (Encode.enum ReadModel.Enum.Game_state_enum.toString |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_neq", Encode.enum ReadModel.Enum.Game_state_enum.toString |> Encode.optional input.neq_ ), ( "_nin", (Encode.enum ReadModel.Enum.Game_state_enum.toString |> Encode.list) |> Encode.optional input.nin_ ) ]


buildGame_state_order_by : (Game_state_order_byOptionalFields -> Game_state_order_byOptionalFields) -> Game_state_order_by
buildGame_state_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { value = Absent }
    in
    { value = optionals.value }


type alias Game_state_order_byOptionalFields =
    { value : OptionalArgument ReadModel.Enum.Order_by.Order_by }


{-| Type for the Game\_state\_order\_by input object.
-}
type alias Game_state_order_by =
    { value : OptionalArgument ReadModel.Enum.Order_by.Order_by }


{-| Encode a Game\_state\_order\_by into a value that can be used as an argument.
-}
encodeGame_state_order_by : Game_state_order_by -> Value
encodeGame_state_order_by input =
    Encode.maybeObject
        [ ( "value", Encode.enum ReadModel.Enum.Order_by.toString |> Encode.optional input.value ) ]


buildGames_bool_exp : (Games_bool_expOptionalFields -> Games_bool_expOptionalFields) -> Games_bool_exp
buildGames_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, gameStateByGameState = Absent, game_state = Absent, id = Absent, moves = Absent, player = Absent, playerByPlayer = Absent, serial_id = Absent }
    in
    Games_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, gameStateByGameState = optionals.gameStateByGameState, game_state = optionals.game_state, id = optionals.id, moves = optionals.moves, player = optionals.player, playerByPlayer = optionals.playerByPlayer, serial_id = optionals.serial_id }


type alias Games_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Games_bool_exp))
    , not_ : OptionalArgument Games_bool_exp
    , or_ : OptionalArgument (List (Maybe Games_bool_exp))
    , gameStateByGameState : OptionalArgument Game_state_bool_exp
    , game_state : OptionalArgument Game_state_enum_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , moves : OptionalArgument Int4_comparison_exp_
    , player : OptionalArgument Player_enum_comparison_exp
    , playerByPlayer : OptionalArgument Player_bool_exp
    , serial_id : OptionalArgument Int_comparison_exp
    }


{-| Type alias for the `Games_bool_exp` attributes. Note that this type
needs to use the `Games_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Games_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Games_bool_exp))
    , not_ : OptionalArgument Games_bool_exp
    , or_ : OptionalArgument (List (Maybe Games_bool_exp))
    , gameStateByGameState : OptionalArgument Game_state_bool_exp
    , game_state : OptionalArgument Game_state_enum_comparison_exp
    , id : OptionalArgument Uuid_comparison_exp
    , moves : OptionalArgument Int4_comparison_exp_
    , player : OptionalArgument Player_enum_comparison_exp
    , playerByPlayer : OptionalArgument Player_bool_exp
    , serial_id : OptionalArgument Int_comparison_exp
    }


{-| Type for the Games\_bool\_exp input object.
-}
type Games_bool_exp
    = Games_bool_exp Games_bool_expRaw


{-| Encode a Games\_bool\_exp into a value that can be used as an argument.
-}
encodeGames_bool_exp : Games_bool_exp -> Value
encodeGames_bool_exp (Games_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeGames_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeGames_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeGames_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "gameStateByGameState", encodeGame_state_bool_exp |> Encode.optional input.gameStateByGameState ), ( "game_state", encodeGame_state_enum_comparison_exp |> Encode.optional input.game_state ), ( "id", encodeUuid_comparison_exp |> Encode.optional input.id ), ( "moves", encodeInt4_comparison_exp_ |> Encode.optional input.moves ), ( "player", encodePlayer_enum_comparison_exp |> Encode.optional input.player ), ( "playerByPlayer", encodePlayer_bool_exp |> Encode.optional input.playerByPlayer ), ( "serial_id", encodeInt_comparison_exp |> Encode.optional input.serial_id ) ]


buildGames_order_by : (Games_order_byOptionalFields -> Games_order_byOptionalFields) -> Games_order_by
buildGames_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { gameStateByGameState = Absent, game_state = Absent, id = Absent, moves = Absent, player = Absent, playerByPlayer = Absent, serial_id = Absent }
    in
    { gameStateByGameState = optionals.gameStateByGameState, game_state = optionals.game_state, id = optionals.id, moves = optionals.moves, player = optionals.player, playerByPlayer = optionals.playerByPlayer, serial_id = optionals.serial_id }


type alias Games_order_byOptionalFields =
    { gameStateByGameState : OptionalArgument Game_state_order_by
    , game_state : OptionalArgument ReadModel.Enum.Order_by.Order_by
    , id : OptionalArgument ReadModel.Enum.Order_by.Order_by
    , moves : OptionalArgument ReadModel.Enum.Order_by.Order_by
    , player : OptionalArgument ReadModel.Enum.Order_by.Order_by
    , playerByPlayer : OptionalArgument Player_order_by
    , serial_id : OptionalArgument ReadModel.Enum.Order_by.Order_by
    }


{-| Type for the Games\_order\_by input object.
-}
type alias Games_order_by =
    { gameStateByGameState : OptionalArgument Game_state_order_by
    , game_state : OptionalArgument ReadModel.Enum.Order_by.Order_by
    , id : OptionalArgument ReadModel.Enum.Order_by.Order_by
    , moves : OptionalArgument ReadModel.Enum.Order_by.Order_by
    , player : OptionalArgument ReadModel.Enum.Order_by.Order_by
    , playerByPlayer : OptionalArgument Player_order_by
    , serial_id : OptionalArgument ReadModel.Enum.Order_by.Order_by
    }


{-| Encode a Games\_order\_by into a value that can be used as an argument.
-}
encodeGames_order_by : Games_order_by -> Value
encodeGames_order_by input =
    Encode.maybeObject
        [ ( "gameStateByGameState", encodeGame_state_order_by |> Encode.optional input.gameStateByGameState ), ( "game_state", Encode.enum ReadModel.Enum.Order_by.toString |> Encode.optional input.game_state ), ( "id", Encode.enum ReadModel.Enum.Order_by.toString |> Encode.optional input.id ), ( "moves", Encode.enum ReadModel.Enum.Order_by.toString |> Encode.optional input.moves ), ( "player", Encode.enum ReadModel.Enum.Order_by.toString |> Encode.optional input.player ), ( "playerByPlayer", encodePlayer_order_by |> Encode.optional input.playerByPlayer ), ( "serial_id", Encode.enum ReadModel.Enum.Order_by.toString |> Encode.optional input.serial_id ) ]


buildInt4_comparison_exp_ : (Int4_comparison_exp_OptionalFields -> Int4_comparison_exp_OptionalFields) -> Int4_comparison_exp_
buildInt4_comparison_exp_ fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Int4_comparison_exp_OptionalFields =
    { eq_ : OptionalArgument ScalarCodecs.Int4_
    , gt_ : OptionalArgument ScalarCodecs.Int4_
    , gte_ : OptionalArgument ScalarCodecs.Int4_
    , in_ : OptionalArgument (List ScalarCodecs.Int4_)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument ScalarCodecs.Int4_
    , lte_ : OptionalArgument ScalarCodecs.Int4_
    , neq_ : OptionalArgument ScalarCodecs.Int4_
    , nin_ : OptionalArgument (List ScalarCodecs.Int4_)
    }


{-| Type for the Int4\_comparison\_exp\_ input object.
-}
type alias Int4_comparison_exp_ =
    { eq_ : OptionalArgument ScalarCodecs.Int4_
    , gt_ : OptionalArgument ScalarCodecs.Int4_
    , gte_ : OptionalArgument ScalarCodecs.Int4_
    , in_ : OptionalArgument (List ScalarCodecs.Int4_)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument ScalarCodecs.Int4_
    , lte_ : OptionalArgument ScalarCodecs.Int4_
    , neq_ : OptionalArgument ScalarCodecs.Int4_
    , nin_ : OptionalArgument (List ScalarCodecs.Int4_)
    }


{-| Encode a Int4\_comparison\_exp\_ into a value that can be used as an argument.
-}
encodeInt4_comparison_exp_ : Int4_comparison_exp_ -> Value
encodeInt4_comparison_exp_ input =
    Encode.maybeObject
        [ ( "_eq", (ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecInt4_) |> Encode.optional input.eq_ ), ( "_gt", (ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecInt4_) |> Encode.optional input.gt_ ), ( "_gte", (ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecInt4_) |> Encode.optional input.gte_ ), ( "_in", ((ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecInt4_) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecInt4_) |> Encode.optional input.lt_ ), ( "_lte", (ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecInt4_) |> Encode.optional input.lte_ ), ( "_neq", (ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecInt4_) |> Encode.optional input.neq_ ), ( "_nin", ((ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecInt4_) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildInt_comparison_exp : (Int_comparison_expOptionalFields -> Int_comparison_expOptionalFields) -> Int_comparison_exp
buildInt_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Int_comparison_expOptionalFields =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Type for the Int\_comparison\_exp input object.
-}
type alias Int_comparison_exp =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List Int)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List Int)
    }


{-| Encode a Int\_comparison\_exp into a value that can be used as an argument.
-}
encodeInt_comparison_exp : Int_comparison_exp -> Value
encodeInt_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.int |> Encode.optional input.eq_ ), ( "_gt", Encode.int |> Encode.optional input.gt_ ), ( "_gte", Encode.int |> Encode.optional input.gte_ ), ( "_in", (Encode.int |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", Encode.int |> Encode.optional input.lt_ ), ( "_lte", Encode.int |> Encode.optional input.lte_ ), ( "_neq", Encode.int |> Encode.optional input.neq_ ), ( "_nin", (Encode.int |> Encode.list) |> Encode.optional input.nin_ ) ]


buildLive_games_args : (Live_games_argsOptionalFields -> Live_games_argsOptionalFields) -> Live_games_args
buildLive_games_args fillOptionals =
    let
        optionals =
            fillOptionals
                { my_id = Absent }
    in
    { my_id = optionals.my_id }


type alias Live_games_argsOptionalFields =
    { my_id : OptionalArgument ScalarCodecs.Uuid }


{-| Type for the Live\_games\_args input object.
-}
type alias Live_games_args =
    { my_id : OptionalArgument ScalarCodecs.Uuid }


{-| Encode a Live\_games\_args into a value that can be used as an argument.
-}
encodeLive_games_args : Live_games_args -> Value
encodeLive_games_args input =
    Encode.maybeObject
        [ ( "my_id", (ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.my_id ) ]


buildMy_challenges_args : (My_challenges_argsOptionalFields -> My_challenges_argsOptionalFields) -> My_challenges_args
buildMy_challenges_args fillOptionals =
    let
        optionals =
            fillOptionals
                { my_id = Absent }
    in
    { my_id = optionals.my_id }


type alias My_challenges_argsOptionalFields =
    { my_id : OptionalArgument ScalarCodecs.Uuid }


{-| Type for the My\_challenges\_args input object.
-}
type alias My_challenges_args =
    { my_id : OptionalArgument ScalarCodecs.Uuid }


{-| Encode a My\_challenges\_args into a value that can be used as an argument.
-}
encodeMy_challenges_args : My_challenges_args -> Value
encodeMy_challenges_args input =
    Encode.maybeObject
        [ ( "my_id", (ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.my_id ) ]


buildMy_games_args : (My_games_argsOptionalFields -> My_games_argsOptionalFields) -> My_games_args
buildMy_games_args fillOptionals =
    let
        optionals =
            fillOptionals
                { my_id = Absent }
    in
    { my_id = optionals.my_id }


type alias My_games_argsOptionalFields =
    { my_id : OptionalArgument ScalarCodecs.Uuid }


{-| Type for the My\_games\_args input object.
-}
type alias My_games_args =
    { my_id : OptionalArgument ScalarCodecs.Uuid }


{-| Encode a My\_games\_args into a value that can be used as an argument.
-}
encodeMy_games_args : My_games_args -> Value
encodeMy_games_args input =
    Encode.maybeObject
        [ ( "my_id", (ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.my_id ) ]


buildPlayer_bool_exp : (Player_bool_expOptionalFields -> Player_bool_expOptionalFields) -> Player_bool_exp
buildPlayer_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, games = Absent, value = Absent }
    in
    Player_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, games = optionals.games, value = optionals.value }


type alias Player_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Player_bool_exp))
    , not_ : OptionalArgument Player_bool_exp
    , or_ : OptionalArgument (List (Maybe Player_bool_exp))
    , games : OptionalArgument Games_bool_exp
    , value : OptionalArgument String_comparison_exp
    }


{-| Type alias for the `Player_bool_exp` attributes. Note that this type
needs to use the `Player_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Player_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Player_bool_exp))
    , not_ : OptionalArgument Player_bool_exp
    , or_ : OptionalArgument (List (Maybe Player_bool_exp))
    , games : OptionalArgument Games_bool_exp
    , value : OptionalArgument String_comparison_exp
    }


{-| Type for the Player\_bool\_exp input object.
-}
type Player_bool_exp
    = Player_bool_exp Player_bool_expRaw


{-| Encode a Player\_bool\_exp into a value that can be used as an argument.
-}
encodePlayer_bool_exp : Player_bool_exp -> Value
encodePlayer_bool_exp (Player_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodePlayer_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodePlayer_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodePlayer_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "games", encodeGames_bool_exp |> Encode.optional input.games ), ( "value", encodeString_comparison_exp |> Encode.optional input.value ) ]


buildPlayer_enum_comparison_exp : (Player_enum_comparison_expOptionalFields -> Player_enum_comparison_expOptionalFields) -> Player_enum_comparison_exp
buildPlayer_enum_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, in_ = Absent, is_null_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, in_ = optionals.in_, is_null_ = optionals.is_null_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Player_enum_comparison_expOptionalFields =
    { eq_ : OptionalArgument ReadModel.Enum.Player_enum.Player_enum
    , in_ : OptionalArgument (List ReadModel.Enum.Player_enum.Player_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument ReadModel.Enum.Player_enum.Player_enum
    , nin_ : OptionalArgument (List ReadModel.Enum.Player_enum.Player_enum)
    }


{-| Type for the Player\_enum\_comparison\_exp input object.
-}
type alias Player_enum_comparison_exp =
    { eq_ : OptionalArgument ReadModel.Enum.Player_enum.Player_enum
    , in_ : OptionalArgument (List ReadModel.Enum.Player_enum.Player_enum)
    , is_null_ : OptionalArgument Bool
    , neq_ : OptionalArgument ReadModel.Enum.Player_enum.Player_enum
    , nin_ : OptionalArgument (List ReadModel.Enum.Player_enum.Player_enum)
    }


{-| Encode a Player\_enum\_comparison\_exp into a value that can be used as an argument.
-}
encodePlayer_enum_comparison_exp : Player_enum_comparison_exp -> Value
encodePlayer_enum_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.enum ReadModel.Enum.Player_enum.toString |> Encode.optional input.eq_ ), ( "_in", (Encode.enum ReadModel.Enum.Player_enum.toString |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_neq", Encode.enum ReadModel.Enum.Player_enum.toString |> Encode.optional input.neq_ ), ( "_nin", (Encode.enum ReadModel.Enum.Player_enum.toString |> Encode.list) |> Encode.optional input.nin_ ) ]


buildPlayer_order_by : (Player_order_byOptionalFields -> Player_order_byOptionalFields) -> Player_order_by
buildPlayer_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { value = Absent }
    in
    { value = optionals.value }


type alias Player_order_byOptionalFields =
    { value : OptionalArgument ReadModel.Enum.Order_by.Order_by }


{-| Type for the Player\_order\_by input object.
-}
type alias Player_order_by =
    { value : OptionalArgument ReadModel.Enum.Order_by.Order_by }


{-| Encode a Player\_order\_by into a value that can be used as an argument.
-}
encodePlayer_order_by : Player_order_by -> Value
encodePlayer_order_by input =
    Encode.maybeObject
        [ ( "value", Encode.enum ReadModel.Enum.Order_by.toString |> Encode.optional input.value ) ]


buildString_comparison_exp : (String_comparison_expOptionalFields -> String_comparison_expOptionalFields) -> String_comparison_exp
buildString_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, nlike_ = Absent, nsimilar_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, ilike_ = optionals.ilike_, in_ = optionals.in_, is_null_ = optionals.is_null_, like_ = optionals.like_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nilike_ = optionals.nilike_, nin_ = optionals.nin_, nlike_ = optionals.nlike_, nsimilar_ = optionals.nsimilar_, similar_ = optionals.similar_ }


type alias String_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the String\_comparison\_exp input object.
-}
type alias String_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List String)
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List String)
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a String\_comparison\_exp into a value that can be used as an argument.
-}
encodeString_comparison_exp : String_comparison_exp -> Value
encodeString_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input.eq_ ), ( "_gt", Encode.string |> Encode.optional input.gt_ ), ( "_gte", Encode.string |> Encode.optional input.gte_ ), ( "_ilike", Encode.string |> Encode.optional input.ilike_ ), ( "_in", (Encode.string |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_like", Encode.string |> Encode.optional input.like_ ), ( "_lt", Encode.string |> Encode.optional input.lt_ ), ( "_lte", Encode.string |> Encode.optional input.lte_ ), ( "_neq", Encode.string |> Encode.optional input.neq_ ), ( "_nilike", Encode.string |> Encode.optional input.nilike_ ), ( "_nin", (Encode.string |> Encode.list) |> Encode.optional input.nin_ ), ( "_nlike", Encode.string |> Encode.optional input.nlike_ ), ( "_nsimilar", Encode.string |> Encode.optional input.nsimilar_ ), ( "_similar", Encode.string |> Encode.optional input.similar_ ) ]


buildUuid_comparison_exp : (Uuid_comparison_expOptionalFields -> Uuid_comparison_expOptionalFields) -> Uuid_comparison_exp
buildUuid_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Uuid_comparison_expOptionalFields =
    { eq_ : OptionalArgument ScalarCodecs.Uuid
    , gt_ : OptionalArgument ScalarCodecs.Uuid
    , gte_ : OptionalArgument ScalarCodecs.Uuid
    , in_ : OptionalArgument (List ScalarCodecs.Uuid)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument ScalarCodecs.Uuid
    , lte_ : OptionalArgument ScalarCodecs.Uuid
    , neq_ : OptionalArgument ScalarCodecs.Uuid
    , nin_ : OptionalArgument (List ScalarCodecs.Uuid)
    }


{-| Type for the Uuid\_comparison\_exp input object.
-}
type alias Uuid_comparison_exp =
    { eq_ : OptionalArgument ScalarCodecs.Uuid
    , gt_ : OptionalArgument ScalarCodecs.Uuid
    , gte_ : OptionalArgument ScalarCodecs.Uuid
    , in_ : OptionalArgument (List ScalarCodecs.Uuid)
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument ScalarCodecs.Uuid
    , lte_ : OptionalArgument ScalarCodecs.Uuid
    , neq_ : OptionalArgument ScalarCodecs.Uuid
    , nin_ : OptionalArgument (List ScalarCodecs.Uuid)
    }


{-| Encode a Uuid\_comparison\_exp into a value that can be used as an argument.
-}
encodeUuid_comparison_exp : Uuid_comparison_exp -> Value
encodeUuid_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.eq_ ), ( "_gt", (ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.gt_ ), ( "_gte", (ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.gte_ ), ( "_in", ((ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecUuid) |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.lt_ ), ( "_lte", (ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.lte_ ), ( "_neq", (ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.neq_ ), ( "_nin", ((ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecUuid) |> Encode.list) |> Encode.optional input.nin_ ) ]


buildVillain_challenges_args : (Villain_challenges_argsOptionalFields -> Villain_challenges_argsOptionalFields) -> Villain_challenges_args
buildVillain_challenges_args fillOptionals =
    let
        optionals =
            fillOptionals
                { my_id = Absent }
    in
    { my_id = optionals.my_id }


type alias Villain_challenges_argsOptionalFields =
    { my_id : OptionalArgument ScalarCodecs.Uuid }


{-| Type for the Villain\_challenges\_args input object.
-}
type alias Villain_challenges_args =
    { my_id : OptionalArgument ScalarCodecs.Uuid }


{-| Encode a Villain\_challenges\_args into a value that can be used as an argument.
-}
encodeVillain_challenges_args : Villain_challenges_args -> Value
encodeVillain_challenges_args input =
    Encode.maybeObject
        [ ( "my_id", (ScalarCodecs.codecs |> ReadModel.Scalar.unwrapEncoder .codecUuid) |> Encode.optional input.my_id ) ]
